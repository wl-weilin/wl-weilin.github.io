---
layout: post
# 标题配置
title:  Activity启动过程

# 时间配置
date:   2021-08-05

# 大类配置
categories: Android-Framework

# 小类配置
tag: AMS

# 设置文章置顶
topping: false

# 资源根路径，该项在Jekyll网页显示时无用
typora-root-url: ./..\..\..
---

* content
{:toc}


# 概述

## 根Activity启动概述

[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)

Activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。

- 根Activity：指的是应用程序启动的第一个Activity，因此根Activity的启动过程一般情况下也可以理解为应用程序的启动过程。
- 普通Activity：指的是除应用程序启动的第一个Activity之外的其他Activity。

根Activity的启动流程更加复杂，所以本文主要介绍根Activity。

## 什么是Launcher

Launcher，也就是我们平时所说的“桌面”，本质上与其他Android应用一样，都是apk应用程序，可以独立安装运行，我们平常使用的系统Launcher都是手机厂商定制后预制到系统里面的。

Launcher 启动后会将已安装应用程序的快捷图标显示到桌面上，这些应用程序的快捷图标就是启动根Activity的入口，当我们点击某个应用程序的快捷图标时，就会通过Launcher请求AMS来启动该应用程序。

当我们点击应用程序的快捷图标时，就会调用Launcher的startActivitySafely方法。

## Activity相关类概述

| 类名                       | 作用                                                         |
| -------------------------- | ------------------------------------------------------------ |
| Activity                   | 写APP时常用的Activity                                        |
| ActivityManagerService     | Android核心服务，负责四大组件的启动，切换，调度等工作。      |
| ActivityStack              | 负责单个Activity栈的状态和管理。其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityStack也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。 |
| ActivityStarter            | 开启Activity的控制器，用于决定一个intent和flags应该如何被传进一下Activity，以及Activity如何与task、stack相关联 |
| ActivityStackSupervisor    | 负责所有Activity栈的管理                                     |
| ActivityTaskManager        | Activity，Service等与ATMS跨进程交互的接口                    |
| ActivityTaskManagerService | 管理Activity行为，控制Activity的生命周期                     |
|                            |                                                              |
| ActivityThread             | 管理应用程序进程的主线程的执行，处理ATMS的调度和执行Activity，Broadcast及相关操作。 |
| ApplicationThread          | 它是ActivityThread的一个内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread与ASM通信的桥梁。 |
| ClientLifecycleManager     | 多个客户端生命周期执行请求管理                               |
| ClientTransaction          | 封装了客户端请求的一些信息，比如要调用的方法、参数等，然后通过 Binder 发送到服务端 |
| Intrumentation             | 负责调用Activity和Application生命周期                        |
| RootWindowContainer        | RootWindowContainer是一个用于管理窗口的类。它的作用是跟踪所有窗口的状态，并负责将它们显示在屏幕上 |
| TransactionExecutor        | 用于处理界面更新事务的类。它的作用是在主线程上处理界面更新请求，以确保所有更新操作都在 UI 线程上执行 |
|                            |                                                              |

 

# Activity启动过程

Base on: Android 12 & Android 13

[startActivity启动过程分析——gityuan](http://gityuan.com/2016/03/12/start-activity/) 

 

## 总过程

(1)   APP端
```
Activity.startActivity(1 args) ->
Activity.startActivity(2 args) ->
Activity.startActivityForResult(2 args) ->
Activity.startActivityForResult(3 args) ->
Instrumentation.execStartActivity()
```
之后调用到system_server端
<br/><br/>

(2)   system_server端
```
ATMS.startActivity() ->
ATMS.startActivityAsUser() ->
ActivityStarter.setxxx() ->
ActivityStarter.execute() -> 
ActivityStarter.executeRequest() ->
ActivityStarter.startActivityUnchecked() ->
ActivityStarter.startActivityInner() ->
RootWindowContainer.resumeFocusedStacksTopActivities() ->
ActivityStack.resumeTopActivityUncheckedLocked() ->
ActivityStack.resumeTopActivityInnerLocked() ->
ASS.startSpecificActivity()
```
在ASS.startSpecificActivity()中又分为两种情况，进程已启动或进程未启动。

- 进程未启动

```
ATMS.startProcessAsync() ->
AMS.startProcess() ->
AMS.startProcessLocked() ->
ProcessList.startProcessLocked(14 args) ->
ProcessList.handleProcessStart() ->
ProcessList.startProcess() ->

// Zygote流程…
// 之后最终走到ATS.realStartActivityLocked()

ActivityThread.main() ->
ActivityThread.attach() ->
AMS.attachApplication() ->
AMS.attachApplicationLocked() ->
ATMS.LocalService.attachApplication() ->
RootWindowContainer.attachApplication()->
RootWindowContainer.AttachApplicationHelper.process(app) ->
WindowContainer.forAllRootTasks(1 args) ->
WindowContainer.forAllRootTasks(2 args) ->
Task.forAllRootTasks() ->
RootWindowContainer.AttachApplicationHelper.accept() ->
WindowContainer.forAllActivities(1 args) ->
WindowContainer.forAllActivities(2 args) ->
ActivityRecord.forAllActivities() ->
RootWindowContainer.AttachApplicationHelper.test() ->
ActivityTaskSupervisor.realStartActivityLocked()
```

- 进程已启动：

直接调用ActivityTaskSupervisor.realStartActivityLocked()

- 共同流程

无论是否启动进程，以下步骤都是一样的。
```
// system_server端
ActivityTaskSupervisor.realStartActivityLocked()
ClientLifecycleManager.scheduleTransaction()

// APP端
ClientTransaction.schedule()
ApplicationThread.scheduleTransaction()
ClientTransactionHandler.scheduleTransaction()
TransactionExecutor.execute()
```

(3)   onCreate生命周期
```
TransactionExecutor.executeCallbacks() ->
LaunchActivityItem.execute() ->
ActivityThread.handleLaunchActivity() ->
ActivityThread.performLaunchActivity() ->
Instrumentation.callActivityOnCreate() ->
Activity.performCreate() ->
MainActivity.onCreate() ->
Activity.onCreate()
```
接下来执行onStart()和onResume()生命周期
```
TransactionExecutor.execute() ->
TransactionExecutor.executeLifecycleState()
```

(4)  onStart生命周期
```
TransactionExecutor.cycleToPath() ->
TransactionExecutor.performLifecycleSequence() ->
ActivityThread.handleStartActivity() ->
Activity.performStart() ->
Instrumentation.callActivityOnStart() ->
MainActivity.onStart() ->
Activity.onStart()
```

(5)  onResume生命周期
```
ResumeActivityItem.execute() ->
ActivityThread.handleResumeActivity() ->
ActivityThread.performResumeActivity() ->
Activity.performResume() ->
Instrumentation.callActivityOnResume() ->
MainActivity.onResume() ->
Activity.onResume() 
```

## 1.应用端启动Activity

```java
public class MainActivity extends Activity implements OnClickListener {
    private final static String LOG_TAG = "MainActivity";

    private Button myButton = null;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        myButton = (Button)findViewById(R.id.myButton);
        myButton.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        if(v.equals(myButton)) {
            Intent intent = new Intent(this, nextActivity.class);
            startActivity(intent);
        }
    }
}
```

## 2.Activity.startActivity()

路径：frameworks/base/core/java/android/app/Activity.java
自定义的MainActivity继承自Activity类，会调用Activity.startActivity()方法，该方法在Activity.java中有两个重载版本。

```java
public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory2,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks2,
        Window.OnWindowDismissedCallback,
        AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient {
//......

@Override
 public void startActivity(Intent intent) {
   this.startActivity(intent, null);
 }

//......

@Override
 public void startActivity(Intent intent, @Nullable Bundle options) {
   if (mIntent != null && mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)
       && mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_CROSS_ACTIVITY*)) {
     if (TextUtils.equals(getPackageName(),
         intent.resolveActivity(getPackageManager()).getPackageName())) {
         // Apply Autofill restore mechanism on the started activity by startActivity()
         final IBinder token =
           mIntent.getIBinderExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN);
         // Remove restore ability from current activity
         mIntent.removeExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN);
         mIntent.removeExtra(AutofillManager.EXTRA_RESTORE_CROSS_ACTIVITY);
         // Put restore token
         intent.putExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN, token);
         intent.putExtra(AutofillManager.EXTRA_RESTORE_CROSS_ACTIVITY*, true);
     }
   }
   if (options != null) {
     startActivityForResult(intent, -1, options);
   } else {
      // Note we want to go through this call for compatibility with
      // applications that may have overridden the method.
      startActivityForResult(intent, -1);
   }
 }
//......
}
```

startActivity()有两个重载函数，最终都会调用startActivity(Intent, Bundle)这个方法，其中Bundle类用于传递数据。

在startActivity()中最后会调用startActivityForResult()。

 

## 3.Activity.startActivityForResult()

startActivityForResult()有两个重载函数，但最终都会调用startActivityForResult(intent, requestCode, options)。startActivityForResult()的第二个参数为 -1，表示 Launcher 不需要知道 Activity 启动的结果。

```java
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {
    startActivityForResult(intent, requestCode, null);
}
 
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
        @Nullable Bundle options) {
    if (mParent == null) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
        // TODO Consider clearing/flushing other event sources and events for child windows.
    } else {
        if (options != null) {
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            // Note we want to go through this method for compatibility with
            // existing applications that may have overridden it.
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}
```

接下来主要调用Instrumentation类的execStartActivity()方法，Instrumentation 类主要用来监控应用程序和系统的交互。

## 4.Instrumentation.execStartActivity()

路径：/frameworks/base/core/java/android/app/Instrumentation.java

```java
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    Uri referrer = target != null ? target.onProvideReferrer() : null;
    if (referrer != null) {
        intent.putExtra(Intent.EXTRA_REFERRER, referrer);
    }
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i=0; i<N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return result;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData(who);
        intent.prepareToLeaveProcess(who);
        int result = ActivityTaskManager.getService().startActivity(whoThread,
                who.getBasePackageName(), who.getAttributionTag(), intent,
                intent.resolveTypeIfNeeded(who.getContentResolver()), token,
                target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
```

execStartActivity()中会调用 ActivityTaskManager.getService().startActivity()，ActivityTaskManager.getService()通过Binder调用获取ActivityTaskManagerService的代理对象，按着调用它的 startActivity 方法。此处startActivity()的共有11个参数。

##  system_server调用

## 5.ATMS.startActivity()

源码路径：
/frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java

```java
@Override
public final int startActivity(IApplicationThread caller, String callingPackage,
        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,
        String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,
        Bundle bOptions) {
    return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,
            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,
            UserHandle.getCallingUserId());
}
```

下面说说每个参数传递ATMS.startActivity()每一项的对应值：

- caller: 当前应用的ApplicationThread对象mAppThread;
- callingPackage: 调用当前ContextImpl.getBasePackageName(),获取当前Activity所在包名;
- intent: 这便是启动Activity时,传递过来的参数;
- resolvedType: 调用intent.resolveTypeIfNeeded而获取;
- resultTo: 来自于当前Activity.mToken
- resultWho: 来自于当前Activity.mEmbeddedID
- requestCode = -1;
- startFlags = 0;
- profilerInfo = null;
- options = null;

startActivity()中调用startActivityAsUser()。startActivityAsUser()比AMS的startActivity()多了一个参数 UserHandle.getCallingUserId()，这个方法会获得调用者的 UserId，AMS 根据这个 UserId 来确定调用者的权限.

## 6.ATMS.startActivityAsUser()

startActivityAsUser()一共有两个重载方法，但最终都会调用13参数的那个方法。比另一个方法多了boolean validateIncomingUser这个参数，且默认为true。

```java
@Override
public int startActivityAsUser(IApplicationThread caller, String callingPackage,
        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,
        String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,
        Bundle bOptions, int userId) {
    return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,
            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
            true /*validateIncomingUser*/);
}

private int startActivityAsUser(IApplicationThread caller, String callingPackage,
        @Nullable String callingFeatureId, Intent intent, String resolvedType,
        IBinder resultTo, String resultWho, int requestCode, int startFlags,
        ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {
    assertPackageMatchesCallingUid(callingPackage);
    //判断调用者进程是否被隔离
    enforceNotIsolatedCaller("startActivityAsUser");
    //检查调用者权限
    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,
            Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser");

    // TODO: Switch to user app stacks here.
    return getActivityStartController().obtainStarter(intent, "startActivityAsUser")
            .setCaller(caller)
            .setCallingPackage(callingPackage)
            .setCallingFeatureId(callingFeatureId)
            .setResolvedType(resolvedType)
            .setResultTo(resultTo)
            .setResultWho(resultWho)
            .setRequestCode(requestCode)
            .setStartFlags(startFlags)
            .setProfilerInfo(profilerInfo)
            .setActivityOptions(bOptions)
            .setUserId(userId)
            .execute();
}
```

 

如果调用者进程被隔离或者无权限，会抛出 SecurityException 异常。

startActivityAsUser()主要部分为最后的return语句。

getActivityStartController()获取到一个 ActivityStartController对象。然后调用ActivityStartController.obtainStarter()，获取一个ActivityStarter对象。然后ActivityStarter调用一系列的set函数。

 

## 7.ActivityStarter.setxxx()

ActivityStarter 是 Android 7.0 中新加入的类，它是加载 Activity 的控制类，会收集所有的逻辑来决定如何将 Intent 和 Flags 转换为 Activity。

ActivityStarter中的set系列方法用于赋值。

```java
ActivityStarter setCaller(IApplicationThread caller) {
    mRequest.caller = caller;
    return this;
}

ActivityStarter setCallingPackage(String callingPackage) {
    mRequest.callingPackage = callingPackage;
    return this;
}

ActivityStarter setCallingFeatureId(String callingFeatureId) {
    mRequest.callingFeatureId = callingFeatureId;
    return this;
}

ActivityStarter setResolvedType(String type) {
    mRequest.resolvedType = type;
    return this;
}
//......
```

可见所有值都赋给了一个mRequest变量，mRequest是一个Request对象。是ActivityStarter的一个内部类。
最终会执行一个execute()方法。

## 8.ActivityStarter.execute()

源码路径：
/frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java

```java
/**
 * Resolve necessary information according the request parameters provided earlier, and execute
 * the request which begin the journey of starting an activity.
 * @return The starter result.
 */
int execute() {
    try {
        // Refuse possible leaked file descriptors
        if (mRequest.intent != null && mRequest.intent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }

        final LaunchingState launchingState;
        synchronized (mService.mGlobalLock) {
            final ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo);
            launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(
                    mRequest.intent, caller);
        }

        // If the caller hasn't already resolved the activity, we're willing
        // to do so here. If the caller is already holding the WM lock here,
        // and we need to check dynamic Uri permissions, then we're forced
        // to assume those permissions are denied to avoid deadlocking.
        if (mRequest.activityInfo == null) {
            mRequest.resolveActivity(mSupervisor);
        }

        int res;
        synchronized (mService.mGlobalLock) {
            final boolean globalConfigWillChange = mRequest.globalConfig != null
                    && mService.getGlobalConfiguration().diff(mRequest.globalConfig) != 0;
            final ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();
            if (stack != null) {
                stack.mConfigWillChange = globalConfigWillChange;
            }
            if (DEBUG_CONFIGURATION) {
                Slog.v(TAG_CONFIGURATION, "Starting activity when config will change = "
                        + globalConfigWillChange);
            }

            final long origId = Binder.clearCallingIdentity();

            res = resolveToHeavyWeightSwitcherIfNeeded();
            if (res != START_SUCCESS) {
                return res;
            }
            res = executeRequest(mRequest);

            Binder.restoreCallingIdentity(origId);

            if (globalConfigWillChange) {
                // If the caller also wants to switch to a new configuration, do so now.
                // This allows a clean switch, as we are waiting for the current activity
                // to pause (so we will not destroy it), and have not yet started the
                // next activity.
                mService.mAmInternal.enforceCallingPermission(
                        android.Manifest.permission.CHANGE_CONFIGURATION,
                        "updateConfiguration()");
                if (stack != null) {
                    stack.mConfigWillChange = false;
                }
                if (DEBUG_CONFIGURATION) {
                    Slog.v(TAG_CONFIGURATION,
                            "Updating to new configuration after starting activity.");
                }
                mService.updateConfigurationLocked(mRequest.globalConfig, null, false);
            }

            // Notify ActivityMetricsLogger that the activity has launched.
            // ActivityMetricsLogger will then wait for the windows to be drawn and populate
            // WaitResult.
            mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res,
                    mLastStartActivityRecord);
            return getExternalResult(mRequest.waitResult == null ? res
                    : waitForResult(res, mLastStartActivityRecord));
        }
    } finally {
        onExecutionComplete();
    }
}
```

## 9.ActivityStarter.executeRequest()

```java
private int executeRequest(Request request) {
//......
 
    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,
            request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask,
            restrictedBgActivity, intentGrants);

    if (request.outActivity != null) {
        request.outActivity[0] = mLastStartActivityRecord;
    }

    return mLastStartActivityResult;
}
```

## 10.ActivityStarter.startActivityUnchecked()

```java
/**
 * Start an activity while most of preliminary checks has been done and caller has been
 * confirmed that holds necessary permissions to do so.
 * Here also ensures that the starting activity is removed if the start wasn't successful.
 */
private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, Task inTask,
            boolean restrictedBgActivity, NeededUriGrants intentGrants) {
    int result = START_CANCELED;
    final ActivityStack startedActivityStack;
    try {
        mService.deferWindowLayout();
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "startActivityInner");
        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,
                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
        startedActivityStack = handleStartResult(r, result);
        mService.continueWindowLayout();
    }

    postStartActivityProcessing(r, result, startedActivityStack);

    return result;
}
```

startActivityUnchecked 方法主要处理与栈管理相关的逻辑。

## 11.ActivityStarter.startActivityInner()


```java
int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        int startFlags, boolean doResume, ActivityOptions options, Task inTask,
        boolean restrictedBgActivity, NeededUriGrants intentGrants) {
    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,
            voiceInteractor, restrictedBgActivity);

    //......
    if (mDoResume) {
        final ActivityRecord topTaskActivity =
                mStartActivity.getTask().topRunningActivityLocked();
        if (!mTargetStack.isTopActivityFocusable()
                || (topTaskActivity != null && topTaskActivity.isTaskOverlay()
                && mStartActivity != topTaskActivity)) {
            // If the activity is not focusable, we can't resume it, but still would like to
            // make sure it becomes visible as it starts (this will also trigger entry
            // animation). An example of this are PIP activities.
            // Also, we don't want to resume activities in a task that currently has an overlay
            // as the starting activity just needs to be in the visible paused state until the
            // over is removed.
            // Passing {@code null} as the start parameter ensures all activities are made
            // visible.
            mTargetStack.ensureActivitiesVisible(null /* starting */,
                    0 /* configChanges */, !PRESERVE_WINDOWS);
            // Go ahead and tell window manager to execute app transition for this activity
            // since the app transition will not be triggered through the resume channel.
            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();
        } else {
            // If the target stack was not previously focusable (previous top running activity
            // on that stack was not visible) then any prior calls to move the stack to the
            // will not update the focused stack.  If starting the new activity now allows the
            // task stack to be focusable, then ensure that we now update the focused stack
            // accordingly.
            if (mTargetStack.isTopActivityFocusable()
                    && !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) {
                mTargetStack.moveToFront("startActivityInner");
            }
            mRootWindowContainer.resumeFocusedStacksTopActivities(
                    mTargetStack, mStartActivity, mOptions);
        }
    }
    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);

    // Update the recent tasks list immediately when the activity starts
    mSupervisor.mRecentTasks.add(mStartActivity.getTask());
    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),
            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);

    return START_SUCCESS;
}
```

启动一个活动，并决定该活动是否应该添加到一个现有任务的顶部，或交付新的意图到一个现有的活动。同时操作活动任务到被请求的或有效的堆栈/显示上。

## 12.RootWindowContainer.resumeFocusedStacksTopActivities()

源码路径：
/frameworks/base/services/core/java/com/android/server/wm/RootWindowContainer.java

```java
boolean resumeFocusedStacksTopActivities(
        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {

    if (!mStackSupervisor.readyToResume()) {
        return false;
    }

    boolean result = false;
    if (targetStack != null && (targetStack.isTopStackInDisplayArea()
            || getTopDisplayFocusedStack() == targetStack)) {
        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
    }

    for (int displayNdx = getChildCount() - 1; displayNdx >= 0; --displayNdx) {
        final DisplayContent display = getChildAt(displayNdx);
        boolean resumedOnDisplay = false;
        for (int tdaNdx = display.getTaskDisplayAreaCount() - 1; tdaNdx >= 0; --tdaNdx) {
            final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);
            for (int sNdx = taskDisplayArea.getStackCount() - 1; sNdx >= 0; --sNdx) {
                final ActivityStack stack = taskDisplayArea.getStackAt(sNdx);
                final ActivityRecord topRunningActivity = stack.topRunningActivity();
                if (!stack.isFocusableAndVisible() || topRunningActivity == null) {
                    continue;
                }
                if (stack == targetStack) {
                    // Simply update the result for targetStack because the targetStack had
                    // already resumed in above. We don't want to resume it again, especially in
                    // some cases, it would cause a second launch failure if app process was
                    // dead.
                    resumedOnDisplay |= result;
                    continue;
                }
                if (taskDisplayArea.isTopStack(stack) && topRunningActivity.isState(RESUMED)) {
                    // Kick off any lingering app transitions form the MoveTaskToFront
                    // operation, but only consider the top task and stack on that display.
                    stack.executeAppTransition(targetOptions);
                } else {
                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);
                }
            }
        }
        if (!resumedOnDisplay) {
            // In cases when there are no valid activities (e.g. device just booted or launcher
            // crashed) it's possible that nothing was resumed on a display. Requesting resume
            // of top activity in focused stack explicitly will make sure that at least home
            // activity is started and resumed, and no recursion occurs.
            final ActivityStack focusedStack = display.getFocusedStack();
            if (focusedStack != null) {
                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);
            } else if (targetStack == null) {
                result |= resumeHomeActivity(null /* prev */, "no-focusable-task",
                        display.getDefaultTaskDisplayArea());
            }
        }
    }

    return result;
}
```

## 13.ActivityStack.resumeTopActivityUncheckedLocked()

源码路径：
/frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java

```java
boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
    if (mInResumeTopActivity) {
        // Don't even start recursing.
        return false;
    }

    boolean result = false;
    try {
        // Protect against recursion.
        mInResumeTopActivity = true;
        result = resumeTopActivityInnerLocked(prev, options);

        // When resuming the top activity, it may be necessary to pause the top activity (for
        // example, returning to the lock screen. We suppress the normal pause logic in
        // {@link #resumeTopActivityUncheckedLocked}, since the top activity is resumed at the
        // end. We call the {@link ActivityStackSupervisor#checkReadyForSleepLocked} again here
        // to ensure any necessary pause logic occurs. In the case where the Activity will be
        // shown regardless of the lock screen, the call to
        // {@link ActivityStackSupervisor#checkReadyForSleepLocked} is skipped.
        final ActivityRecord next = topRunningActivity(true /* focusableOnly */);
        if (next == null || !next.canTurnScreenOn()) {
            checkReadyForSleep();
        }
    } finally {
        mInResumeTopActivity = false;
    }

    return result;
}
```

## 14.ActivityStack.resumeTopActivityInnerLocked()


## 15.ATS.startSpecificActivity()

Base on: Android T
源码路径：frameworks/base/services/core/java/com/android/server/wm/ActivityTaskSupervisor.java
ATS=ActivityTaskSupervisor

```java
void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
    // Is this activity's application already running?
    final WindowProcessController wpc =
            mService.getProcessController(r.processName, r.info.applicationInfo.uid);

    boolean knownToBeDead = false;
    if (wpc != null && wpc.hasThread()) {
        try {
            realStartActivityLocked(r, wpc, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, "Exception when starting activity "
                    + r.intent.getComponent().flattenToShortString(), e);
        }

        // If a dead object exception was thrown -- fall through to
        // restart the application.
        knownToBeDead = true;
    }

    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();

    final boolean isTop = andResume && r.isTopRunningActivity();
    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? "top-activity" : "activity");
}
```

### 进程已存在->ATS.realStartActivityLocked()

ATS=ActivityTaskSupervisor
如果当前Activity所在进程已启动，则直接调用realStartActivityLocked()。

```java
if (wpc != null && wpc.hasThread()) {
    try {
        realStartActivityLocked(r, wpc, andResume, checkConfig);
        return;
    } catch (RemoteException e) {
        Slog.w(TAG, "Exception when starting activity "
                + r.intent.getComponent().flattenToShortString(), e);
    }

    // If a dead object exception was thrown -- fall through to
    // restart the application.
    knownToBeDead = true;
}
```

### 进程不存在->AMS.startProcessLocked()

如果承载当前Activity的进程还不存在，则应该通过ATMS.startProcessAsync()先启动进程。

```txt
ATMS.startProcessAsync() {
final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,
     mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,
     isTop, hostingType, activity.intent.getComponent());
 mH.sendMessage(m);
} ->

AMS.startProcess()
AMS.startProcessLocked()
ProcessList.startProcessLocked()
ProcessList.startProcessLocked(14 args)
ProcessList.handleProcessStart()
ProcessList.startProcess()
Zygote流程：略
APP端流程：
ActivityThread.main() ->
ActivityThread.attach() ->
AMS.attachApplication() ->
AMS.attachApplicationLocked() ->
…
```

全部堆栈如下图：

<div style="text-align: center">
    <img src="/wl-docs/Android Framework/AMS/Activity启动堆栈.png" alt="示例图片.png" style="zoom:80%" />
</div>
经过以上流程开启进程后，继续调用到realStartActivityLocked()，之后同进程已存在的流程一致。



## 16.ATS.realStartActivityLocked()

ATS=ActivityTaskSupervisor
执行到此处，无论之前进程是否已启动，在这里则都启动了。

```java
boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
        boolean andResume, boolean checkConfig) throws RemoteException {
    //......
    try {
        //......
        try {
            //......
            // Create activity launch transaction.
            final ClientTransaction clientTransaction = ClientTransaction.obtain(
                    proc.getThread(), r.appToken);

            final DisplayContent dc = r.getDisplay().mDisplayContent;
            clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
                    System.identityHashCode(r), r.info,
                    // TODO: Have this take the merged configuration instead of separate global
                    // and override configs.
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),
                    r.getSavedState(), r.getPersistentSavedState(), results, newIntents,
                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),
                    r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));

            // Set desired final state.
            final ActivityLifecycleItem lifecycleItem;
            if (andResume) {
                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());
            } else {
                lifecycleItem = PauseActivityItem.obtain();
            }
            clientTransaction.setLifecycleStateRequest(lifecycleItem);

            // Schedule transaction.
            mService.getLifecycleManager().scheduleTransaction(clientTransaction);

            //......

        } catch (RemoteException e) {
            //......
        }
    } finally {
        endDeferResume();
        proc.resumeConfigurationDispatch();
    }

    //......

    return true;
}
```

主要看这两处代码：

```java
final ClientTransaction clientTransaction = ClientTransaction.obtain(
        proc.getThread(), r.appToken);

mService.getLifecycleManager().scheduleTransaction(clientTransaction);
```

proc.getThread()是一个IApplicationThread对象，通过ClientTransaction.obtain()获取到一个ClientTransaction类的单例对象，其中将clientTransaction.mClient=proc.getThread()。

## 17.ClientLifecycleManager.scheduleTransaction()

源码路径：frameworks/base/services/core/java/com/android/server/wm/ClientLifecycleManager.java

## system_server端结束

## 18.ClientTransaction.schedule()

源码路径：frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java

## 19.ApplicationThread.scheduleTransaction()

```java
@Override
public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
    ActivityThread.this.scheduleTransaction(transaction);
}
```

## 20.ClientTransactionHandler.scheduleTransaction()

```java
void scheduleTransaction(ClientTransaction transaction) {
    transaction.preExecute(this);
    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
}
```

向APP端发送消息及数据。然后通过ActivityThread.java中的handleMessage(Message msg)接收消息并执行相应代码。

```java
public void handleMessage(Message msg) {
    if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
    switch (msg.what) {
//......
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
        break;
        //......
  }
  //......
}
```

代码跳转到mTransactionExecutor.execute(transaction)。

## 21.TransactionExecutor.execute()

```java
/**
 * Resolve transaction.
 * First all callbacks will be executed in the order they appear in the list. If a callback
 * requires a certain pre- or post-execution state, the client will be transitioned accordingly.
 * Then the client will cycle to the final lifecycle state if provided. Otherwise, it will
 * either remain in the initial state, or last state needed by a callback.
 */
public void execute(ClientTransaction transaction) {
    if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Start resolving transaction");

    final IBinder token = transaction.getActivityToken();
    if (token != null) {
        final Map<IBinder, ClientTransactionItem> activitiesToBeDestroyed =
                mTransactionHandler.getActivitiesToBeDestroyed();
        final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token);
        if (destroyItem != null) {
            if (transaction.getLifecycleStateRequest() == destroyItem) {
                // It is going to execute the transaction that will destroy activity with the
                // token, so the corresponding to-be-destroyed record can be removed.
                activitiesToBeDestroyed.remove(token);
            }
            if (mTransactionHandler.getActivityClient(token) == null) {
                // The activity has not been created but has been requested to destroy, so all
                // transactions for the token are just like being cancelled.
                Slog.w(TAG, tId(transaction) + "Skip pre-destroyed transaction:\n"
                        + transactionToString(transaction, mTransactionHandler));
                return;
            }
        }
    }

    if (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler));

    executeCallbacks(transaction);

    executeLifecycleState(transaction);
    mPendingActions.clear();
    if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "End resolving transaction");
}
```

通过TransactionExecutor真正处理ClientTransaction中封装的Activity相关信息。

在TransactionExecutor.execute()中，APP端的生命周期从这里真正地开始执行，首先通过executeCallbacks(transaction)跳转到onCreate生命周期的一系列方法中去。然后再到executeLifecycleState(transaction)中执行onStart和onResume方法。

## 22.onCreate生命周期

### TransactionExecutor.executeCallbacks()

```java
@VisibleForTesting
public void executeCallbacks(ClientTransaction transaction) {
    final List<ClientTransactionItem> callbacks = transaction.getCallbacks();
    if (callbacks == null || callbacks.isEmpty()) {
        // No callbacks to execute, return early.
        return;
    }
    if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Resolving callbacks in transaction");

    final IBinder token = transaction.getActivityToken();
    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);

    // In case when post-execution state of the last callback matches the final state requested
    // for the activity in this transaction, we won't do the last transition here and do it when
    // moving to final state instead (because it may contain additional parameters from server).
    final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();
    final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState()
            : UNDEFINED;
    // Index of the last callback that requests some post-execution state.
    final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);

    final int size = callbacks.size();
    for (int i = 0; i < size; ++i) {
        final ClientTransactionItem item = callbacks.get(i);
        if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Resolving callback: " + item);
        final int postExecutionState = item.getPostExecutionState();
        final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r,
                item.getPostExecutionState());
        if (closestPreExecutionState != UNDEFINED) {
            cycleToPath(r, closestPreExecutionState, transaction);
        }

        item.execute(mTransactionHandler, token, mPendingActions);
        item.postExecute(mTransactionHandler, token, mPendingActions);
        if (r == null) {
            // Launch activity request will create an activity record.
            r = mTransactionHandler.getActivityClient(token);
        }

        if (postExecutionState != UNDEFINED && r != null) {
            // Skip the very last transition and perform it by explicit state request instead.
            final boolean shouldExcludeLastTransition =
                    i == lastCallbackRequestingState && finalState == postExecutionState;
            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);
        }
    }
}
```

通过item.execute(mTransactionHandler, token, mPendingActions)跳转到下一步，item在此处的声明是一个ClientTransactionItem（抽象类），但它实际上是一个LaunchActivityItem对象。

### LaunchActivityItem.execute()

```java
@Override
public void execute(ClientTransactionHandler client, IBinder token,
        PendingTransactionActions pendingActions) {
    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, "activityStart");
    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,
            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,
            mPendingResults, mPendingNewIntents, mIsForward,
            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);
    client.handleLaunchActivity(r, pendingActions, null /* customIntent */);
    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
}
```

此处的client是一个ActivityThread对象。

### ActivityThread.handleLaunchActivity()

```java
public Activity handleLaunchActivity(ActivityClientRecord r,
        PendingTransactionActions pendingActions, Intent customIntent) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();
    mSomeActivitiesChanged = true;

    if (r.profilerInfo != null) {
        mProfiler.setProfiler(r.profilerInfo);
        mProfiler.startProfiling();
    }

    if (r.mPendingFixedRotationAdjustments != null) {
        // The rotation adjustments must be applied before handling configuration, so process
        // level display metrics can be adjusted.
        overrideApplicationDisplayAdjustments(r.token, adjustments ->
                adjustments.setFixedRotationAdjustments(r.mPendingFixedRotationAdjustments));
    }

    // Make sure we are running with the most recent config.
    handleConfigurationChanged(null, null);

    if (localLOGV) Slog.v(
        TAG, "Handling launch of " + r);

    // Initialize before creating the activity
    if (!ThreadedRenderer.sRendererDisabled
            && (r.activityInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
        HardwareRenderer.preload();
    }
    WindowManagerGlobal.initialize();

    // Hint the GraphicsEnvironment that an activity is launching on the process.
    GraphicsEnvironment.hintActivityLaunch();

    final Activity a = performLaunchActivity(r, customIntent);

    if (a != null) {
        r.createdConfig = new Configuration(mConfiguration);
        reportSizeConfigurations(r);
        if (!r.activity.mFinished && pendingActions != null) {
            pendingActions.setOldState(r.state);
            pendingActions.setRestoreInstanceState(true);
            pendingActions.setCallOnPostCreate(true);
        }
    } else {
        // If there was an error, for any reason, tell the activity manager to stop us.
        try {
            ActivityTaskManager.getService()
                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
    }

    return a;
}
```

### ActivityThread.performLaunchActivity()

```java
/**  Core implementation of activity launch. */
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ActivityInfo aInfo = r.activityInfo;
//......
    ContextImpl appContext = createBaseContextForActivity(r);
    Activity activity = null;
    try {
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state != null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
        if (!mInstrumentation.onException(activity, e)) {
            throw new RuntimeException(
                "Unable to instantiate activity " + component
                + ": " + e.toString(), e);
        }
    }

    try {
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);

        if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
        if (localLOGV) Slog.v(
                TAG, r + ": app=" + app
                + ", appName=" + app.getPackageName()
                + ", pkg=" + r.packageInfo.getPackageName()
                + ", comp=" + r.intent.getComponent().toShortString()
                + ", dir=" + r.packageInfo.getAppDir());

        if (activity != null) {
            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
            Configuration config = new Configuration(mCompatConfiguration);
            if (r.overrideConfig != null) {
                config.updateFrom(r.overrideConfig);
            }
            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                    + r.activityInfo.name + " with config " + config);
            Window window = null;
            if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                window = r.mPendingRemoveWindow;
                r.mPendingRemoveWindow = null;
                r.mPendingRemoveWindowManager = null;
            }

            // Activity resources must be initialized with the same loaders as the
            // application context.
            appContext.getResources().addLoaders(
                    app.getResources().getLoaders().toArray(new ResourcesLoader[0]));

            appContext.setOuterContext(activity);
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window, r.configCallback,
                    r.assistToken);

            if (customIntent != null) {
                activity.mIntent = customIntent;
            }
            r.lastNonConfigurationInstances = null;
            checkAndBlockForNetworkAccess();
            activity.mStartedActivity = false;
            int theme = r.activityInfo.getThemeResource();
            if (theme != 0) {
                activity.setTheme(theme);
            }

            activity.mCalled = false;
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }
            if (!activity.mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + r.intent.getComponent().toShortString() +
                    " did not call through to super.onCreate()");
            }
            r.activity = activity;
            mLastReportedWindowingMode.put(activity.getActivityToken(),
                    config.windowConfiguration.getWindowingMode());
        }
        r.setState(ON_CREATE);

        // updatePendingActivityConfiguration() reads from mActivities to update
        // ActivityClientRecord which runs in a different thread. Protect modifications to
        // mActivities to avoid race.
        synchronized (mResourcesManager) {
            mActivities.put(r.token, r);
        }

    } catch (SuperNotCalledException e) {
        throw e;

    } catch (Exception e) {
        if (!mInstrumentation.onException(activity, e)) {
            throw new RuntimeException(
                "Unable to start activity " + component
                + ": " + e.toString(), e);
        }
    }

    return activity;
}
```

### Instrumentation.callActivityOnCreate()

```java
public void callActivityOnCreate(Activity activity, Bundle icicle,
        PersistableBundle persistentState) {
    prePerformCreate(activity);
    activity.performCreate(icicle, persistentState);
    postPerformCreate(activity);
}
```

### Activity.performCreate()

```java
final void performCreate(Bundle icicle, PersistableBundle persistentState) {
    dispatchActivityPreCreated(icicle);
    mCanEnterPictureInPicture = true;
    // initialize mIsInMultiWindowMode and mIsInPictureInPictureMode before onCreate
    final int windowingMode = getResources().getConfiguration().windowConfiguration
            .getWindowingMode();
    mIsInMultiWindowMode = inMultiWindowMode(windowingMode);
    mIsInPictureInPictureMode = windowingMode == WINDOWING_MODE_PINNED;
    restoreHasCurrentPermissionRequest(icicle);
    if (persistentState != null) {
        onCreate(icicle, persistentState);
    } else {
        onCreate(icicle);
    }
    EventLogTags.writeWmOnCreateCalled(mIdent, getComponentName().getClassName(),
            "performCreate");
    mActivityTransitionState.readState(icicle);

    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
            com.android.internal.R.styleable.Window_windowNoDisplay, false);
    mFragments.dispatchActivityCreated();
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    dispatchActivityPostCreated(icicle);
}
```

这一步中，执行完自定义Activity的onCreate()后，会打印wm_on_restart_called日志。

### MainActivity.onCreate()

进入到用户自定义的Activity中，执行onCreate()。

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String myTAG = "onCreate";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
    @Override
    protected void onStart() {
        super.onStart();
        String myTAG = "onStart";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }

    @Override
    protected void onResume() {
        super.onResume();
        String myTAG = "onResume";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
}
```

### Activity.onCreate()

```java
protected void onCreate(@Nullable Bundle savedInstanceState) {
    if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);

    if (mLastNonConfigurationInstances != null) {
        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);
        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,
                View.LAST_APP_AUTOFILL_ID);

        if (mAutoFillResetNeeded) {
            getAutofillManager().onCreate(savedInstanceState);
        }

        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null
                ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    dispatchActivityCreated(savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mRestoredFromBundle = savedInstanceState != null;
    mCalled = true;

}
```

onCreate调用栈：
```txt
at com.demoapp.activitydemo.MainActivity.onCreate(MainActivity.java:20)
at android.app.Activity.performCreate(Activity.java:8235)
at android.app.Activity.performCreate(Activity.java:8206)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1310)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3560)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3747)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2173)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loop(Looper.java:236)
at android.app.ActivityThread.main(ActivityThread.java:8168)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)
```

## 23.TransactionExecutor.executeLifecycleState()

此处由TransactionExecutor.execute()调用而来。

## 24.onStart生命周期

调用堆栈：
```txt
at com.demoapp.activitydemo.MainActivity.onStart(MainActivity.java:36)
at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1436)
at android.app.Activity.performStart(Activity.java:8266)
at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3613)
at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)
at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)
at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2173)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loop(Looper.java:236)
at android.app.ActivityThread.main(ActivityThread.java:8168)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)
```

### TransactionExecutor.cycleToPath()

### TransactionExecutor.performLifecycleSequence()

### ActivityThread.handleStartActivity()

### Activity.performStart()

### Instrumentation.callActivityOnStart()

### MainActivity.onStart()

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String myTAG = "onCreate";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
    @Override
    protected void onStart() {
        super.onStart();
        String myTAG = "onStart";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }

    @Override
    protected void onResume() {
        super.onResume();
        String myTAG = "onResume";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
}
```

### Activity.onStart()

```java
protected void onStart() {
    if (DEBUG_LIFECYCLE) Slog.v(TAG, "onStart " + this);
    mCalled = true;

    mFragments.doLoaderStart();

    dispatchActivityStarted();

    if (mAutoFillResetNeeded) {
        getAutofillManager().onVisibleForAutofill();
    }
}
```

## 25.onResume生命周期
onResume()堆栈：
```txt
at com.demoapp.activitydemo.MainActivity.onResume(MainActivity.java:43)
at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1457)
at android.app.Activity.performResume(Activity.java:8390)
at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4601)
at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4643)
at android.app.servertransaction.ResumeActivityItem.execute(ResumeActivityItem.java:52)
at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:176)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2173)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loop(Looper.java:236)
at android.app.ActivityThread.main(ActivityThread.java:8168)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)

```

### ResumeActivityItem.execute()

### ActivityThread.handleResumeActivity()

### ActivityThread.performResumeActivity()

### Activity.performResume()

### Instrumentation.callActivityOnResume()

### MainActivity.onResume()

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String myTAG = "onCreate";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
    @Override
    protected void onStart() {
        super.onStart();
        String myTAG = "onStart";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }

    @Override
    protected void onResume() {
        super.onResume();
        String myTAG = "onResume";
        Log.d(myTAG , Log.getStackTraceString(new Throwable()));
    }
}
```

### Activity.onResume()

```java
protected void onResume() {
    if (DEBUG_LIFECYCLE) Slog.v(TAG, "onResume " + this);
    dispatchActivityResumed();
    mActivityTransitionState.onResume(this);
    enableAutofillCompatibilityIfNeeded();
    if (mAutoFillResetNeeded) {
        if (!mAutoFillIgnoreFirstResumePause) {
            View focus = getCurrentFocus();
            if (focus != null && focus.canNotifyAutofillEnterExitEvent()) {
                // TODO(b/148815880): Bring up keyboard if resumed from inline authentication.
                // TODO: in Activity killed/recreated case, i.e. SessionLifecycleTest#
                // testDatasetVisibleWhileAutofilledAppIsLifecycled: the View's initial
                // window visibility after recreation is INVISIBLE in onResume() and next frame
                // ViewRootImpl.performTraversals() changes window visibility to VISIBLE.
                // So we cannot call View.notifyEnterOrExited() which will do nothing
                // when View.isVisibleToUser() is false.
                getAutofillManager().notifyViewEntered(focus);
            }
        }
    }

    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_RESUME);

    mCalled = true;
}
```

